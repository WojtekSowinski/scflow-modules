module Main where
import Data.List.Extra (splitOn, replace)
import Data.Maybe (fromJust, fromMaybe)
import Data.List ( nub, sortOn )
import System.Environment (getArgs)
import Control.Monad (forM_)
import Control.Lens.Extras (template)
import Data.Char (toLower)
import Control.Monad.Extra (forM)

type Dictionary k v = [(k,v)]
data ScriptInfo = ScriptInfo {
    name :: String,
    scflowCalls :: [String],
    calledSourceFiles :: [String],
    rMarkdownTemplates :: [String],
    rDependencies :: [String],
    systemDependencies :: [String]
} deriving Show

printScriptInfo :: ScriptInfo -> IO ()
printScriptInfo script = do
    putStrLn $ "SCRIPT NAME: " ++ name script
    putStrLn "SCFLOW CALLS:"
    putStrLn $ unlines $ scflowCalls script
    putStrLn "CALLED SOURCE FILES:"
    putStrLn $ unlines $ calledSourceFiles script
    putStrLn "RMARKDOWN TEMPLATES USED BY THE SCRIPT:"
    putStrLn $ unlines $ rMarkdownTemplates script
    putStrLn "IMPORTS USED (DIRECTLY OR INDIRECTLY) IN THE SCRIPT:"
    putStrLn $ unlines $ rDependencies script
    putStrLn "SYSTEM PACKAGES REQUIRED:"
    putStrLn $ unlines $ systemDependencies script


aggregateScriptInfo :: [ScriptInfo] -> ScriptInfo
aggregateScriptInfo pkgs = ScriptInfo {
    name = "all",
    scflowCalls = alphabeticalSort $ concatMap scflowCalls pkgs,
    calledSourceFiles = alphabeticalSort $ concatMap calledSourceFiles pkgs,
    rMarkdownTemplates = alphabeticalSort $ concatMap rMarkdownTemplates pkgs,
    rDependencies = alphabeticalSort $ concatMap rDependencies pkgs,
    systemDependencies = alphabeticalSort $ concatMap systemDependencies pkgs
    }

-- Make a dictionary based on an imput file. The file is in the following format:
-- key1
-- value1
-- value2
--
-- key2
-- value3
-- value4
-- value5
-- .
-- .
-- .
mkDictFromFile :: FilePath -> IO (Dictionary String [String])
mkDictFromFile f = map ((\(x:xs) -> (x,xs)) . lines) . filter (/="") . splitOn "\n\n" <$> readFile f

-- Search a dictionary. if key is not found, return an empty list
lookUpOrEmpty :: Eq k => k -> Dictionary k [v] -> [v]
lookUpOrEmpty key dict = fromMaybe [] $ lookup key dict

mapValsToKeys :: Dictionary k [v] -> Dictionary v k
mapValsToKeys = concatMap (\(k,vs) -> [(v,k) | v <- vs])

type Graph a = Dictionary a [a]

-- Depht-first search a graph represented as adjacency lists.
dfs :: (Eq n) => Graph n -> n -> [n]
dfs adjList = dfs' adjList []
dfs' adjList visited start
    | start `elem` visited = []
    | otherwise = start : concatMap (dfs' adjList (start:visited)) next
        where next = lookUpOrEmpty start adjList

alphabeticalSort :: [String] -> [String]
alphabeticalSort = sortOn (map toLower) . nub

main :: IO ()
main = do
    -- Read data from pregenerated files. These were made by running rg in
    -- the ScFlow codebase and manually filtering the results
    functionDefs <- mkDictFromFile "function-definitions"
    let functionLocations = mapValsToKeys functionDefs
    internalCallDict <- mkDictFromFile "scflow-internal-calls"
    directCallDict <- mkDictFromFile "scflow-calls-in-pipeline"
    importsInPipeline <- mkDictFromFile "imports-in-pipeline"
    importsInRPackage <- mkDictFromFile "imports-in-r-package"
    templateFileReferences <- mkDictFromFile "template-file-references"
    reportTemplateImports <- mkDictFromFile "imports-in-report-templates"

    -- System dependencies for R packages (generated by running get-all-sys-deps.r)
    systemRequirementDict <- mkDictFromFile "r-pkg-system-reqs"

    args <- getArgs
    scripts <- forM args (\nfScript -> do
        putStrLn "--------------------------------------"

        -- Find all calls to functions defined in the ScFlow R package.
        let directScFlowCalls = lookUpOrEmpty nfScript directCallDict
        let indirectScFlowCalls = concatMap (dfs internalCallDict) directScFlowCalls
        let allScFlowCalls = alphabeticalSort $ directScFlowCalls ++ indirectScFlowCalls

        -- Find all R files needed to run the script.
        let sourceFiles = alphabeticalSort $ map (`lookUpOrEmpty` functionLocations) allScFlowCalls

        -- Display all .Rmd template files referenced by the script.
        let usedTemplates = alphabeticalSort $ concatMap (`lookUpOrEmpty` templateFileReferences) allScFlowCalls

        -- Find all packages which need to be imported for the script to work.
        let directImports = lookUpOrEmpty nfScript importsInPipeline
        let internalImports = concatMap (`lookUpOrEmpty` importsInRPackage) sourceFiles
        let reportImports = concatMap (`lookUpOrEmpty` reportTemplateImports) usedTemplates
        let allImports = alphabeticalSort $ directImports ++ internalImports ++ reportImports

        -- Find all needed system packages.
        let sysReqs = alphabeticalSort $ concatMap (`lookUpOrEmpty` systemRequirementDict) allImports

        let summary = ScriptInfo nfScript allScFlowCalls sourceFiles usedTemplates allImports sysReqs
        printScriptInfo summary
        putStrLn ""
        return summary
        )
    putStrLn "--------------------------------------"
    printScriptInfo $ aggregateScriptInfo scripts
